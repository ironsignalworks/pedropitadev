<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Pedro Pita — creative web engineering</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
      :root { --accent:#00e5ff; }
      html, body { height: 100%; font-family: 'Roboto Mono', monospace; }
      body {
        margin: 0;
        background: #000;
        overflow: hidden;
        font-family: 'Roboto Mono', monospace;
      }
      #bgCanvas, #textCanvas { position: fixed; inset: 0; width: 100%; height: 100%; }
      #bgCanvas { z-index: 0; pointer-events: none; }
      #textCanvas { z-index: 1; }
      body.hover-link { cursor: pointer; }
      #resumeLayer {
        position: fixed;
        inset: 0;
        background: #000;
        transform: translateY(110%);
        transition: transform 0.9s cubic-bezier(0.22, 1, 0.36, 1);
        z-index: 3;
        pointer-events: none;
        overflow-y: auto;
        padding: 2rem;
        scrollbar-width: thin;
        scrollbar-color: #1a1a1a #000;
      }
      #resumeLayer.visible {
        transform: translateY(0);
        pointer-events: auto;
      }
      #resumeLayer .resume-content {
        max-width: 960px;
        margin: 0 auto;
        color: rgba(255, 255, 255, 0.9);
        font-family: 'Roboto Mono', monospace;
        line-height: 1.6;
      }
      #resumeLayer .resume-content .actions {
        display: flex;
        justify-content: flex-start;
        align-items: center;
        margin-bottom: 1rem;
        gap: 0.5rem;
      }
      #resumeLayer .resume-content .btn {
        appearance: none;
        border: 1px solid rgba(255, 255, 255, 0.35);
        background: #000;
        color: #fff;
        font-family: 'Roboto Mono', monospace;
        font-size: 0.95rem;
        padding: 0.4rem 0.85rem;
        border-radius: 0;
        cursor: pointer;
        transition: border-color 0.2s, transform 0.08s;
      }
      #resumeLayer .resume-content .btn:hover { border-color: rgba(255, 255, 255, 0.65); }
      #resumeLayer .resume-content .btn:active { transform: translateY(1px); }
      @media (max-width: 720px) {
        #resumeLayer {
          padding: 1.25rem;
        }
      }
      #resumeLayer .resume-content h1,
      #resumeLayer .resume-content h2,
      #resumeLayer .resume-content h3,
      #resumeLayer .resume-content h4,
      #resumeLayer .resume-content h5,
      #resumeLayer .resume-content h6 {
        font-family: 'Roboto Mono', monospace;
        margin-top: 1.25rem;
        margin-bottom: 0.35rem;
        color: #00e5ff;
      }
      #resumeLayer .resume-content p,
      #resumeLayer .resume-content ul {
        margin-bottom: 1rem;
      }
      #resumeLayer .resume-content a {
        color: #00e5ff;
      }
      #resumeLayer::-webkit-scrollbar {
        width: 10px;
      }
      #resumeLayer::-webkit-scrollbar-track {
        background: #000;
      }
      #resumeLayer::-webkit-scrollbar-thumb {
        background: #1a1a1a;
      }
      @media print {
        @page { margin: 8mm; size: A4 portrait; }
        html, body {
          margin: 0;
          height: auto;
          overflow: visible;
          font-size: calc(0.78rem + 2px);
        }
        #bgCanvas, #textCanvas {
          display: none;
        }
        #resumeLayer {
          position: static;
          inset: auto;
          height: auto;
          overflow: visible;
          transform: translateY(0) !important;
          pointer-events: none;
          background: #000;
          padding: 0;
          scrollbar-width: none;
          box-shadow: none;
          max-width: 100%;
          width: 100%;
          page-break-after: avoid;
          page-break-inside: avoid;
        }
        #resumeLayer .resume-content {
          max-width: 100%;
          padding: 0;
          font-size: calc(0.85rem + 2px);
          line-height: 1.4;
          page-break-inside: avoid;
        }
        #resumeLayer .resume-content p,
        #resumeLayer .resume-content .meta {
          margin-bottom: 0.65rem;
        }
        #resumeLayer .resume-content p:last-child {
          margin-bottom: 0;
        }
        #resumeLayer .resume-content .actions {
          display: none !important;
        }
        #resumeLayer .resume-content h1,
        #resumeLayer .resume-content h2,
        #resumeLayer .resume-content h3,
        #resumeLayer .resume-content h4,
        #resumeLayer .resume-content h5,
        #resumeLayer .resume-content h6 {
          color: #f5f5f5;
        }
      }
    </style>
  </head>
  <body>

<script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
      "three/webgpu": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.webgpu.js",
  
      /* TSL alias: Nodes re-exports the same TSL API */
      "three/tsl": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/nodes/Nodes.js",
  
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
    }
  }
  </script>
  
    <script type="importmap">
      {
        "imports": {
          "three": "../build/three.module.js",
          "three/webgpu": "../build/three.webgpu.js",
          "three/tsl": "../build/three.tsl.js",
          "three/addons/": "./jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREEGL from 'three';                 // WebGL overlay (text)
      import * as THREEGPU from 'three/webgpu';         // WebGPU background
      import { texture, textureStore, Fn, instanceIndex, float, uvec2, vec2, vec3, vec4, uniform } from 'three/tsl';
      import WebGPU from 'three/addons/capabilities/WebGPU.js';
      import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';
      import { Font } from 'three/addons/loaders/FontLoader.js';
      import { unzipSync, strFromU8 } from 'three/addons/libs/fflate.module.js';

      // ---------- BACKGROUND (WebGPU) ----------
      let gpuRenderer, bgScene, bgCamera, bgPlane, computeNode;
      const bgCanvas = document.createElement('canvas');
      bgCanvas.id = 'bgCanvas';
      document.body.appendChild(bgCanvas);

      // uniforms (TSL) for reactive plasma
      const uTime   = uniform(0);
      const uMouse  = uniform(new THREEGL.Vector2(0.5, 0.5)); // normalized [0..1]
      const uAspect = uniform(1.0);
      const targetMouse = { x: Math.random(), y: Math.random() };     // smoothed target

      // ---------- TEXT OVERLAY (WebGL) ----------
      let glRenderer, textScene, textCamera;
      const textCanvas = document.createElement('canvas');
      textCanvas.id = 'textCanvas';
      document.body.appendChild(textCanvas);

      const resumeLayer = document.createElement('div');
      resumeLayer.id = 'resumeLayer';
      resumeLayer.innerHTML = `
        <div class="resume-content"></div>
      `;
      document.body.appendChild(resumeLayer);
      const resumeContent = resumeLayer.querySelector('.resume-content');
      const shareResumeHandler = async (event) => {
        const shareBtn = event.currentTarget;
        const url = new URL(window.location.href);
        url.searchParams.set('clean', '1');
        const shareData = {
          title: 'Pedro Pita - Resume',
          text: 'Resume - Creative Technologist & Web Developer',
          url: url.toString()
        };
        if (navigator.share) {
          try {
            await navigator.share(shareData);
          } catch {
            // user canceled share
          }
          return;
        }
        if (navigator.clipboard && window.isSecureContext) {
          try {
            await navigator.clipboard.writeText(shareData.url);
            if (shareBtn) {
              const previous = shareBtn.textContent;
              shareBtn.textContent = 'Link copied!';
              setTimeout(() => {
                shareBtn.textContent = previous;
              }, 1400);
            }
            return;
          } catch {
            window.prompt('Copy this URL:', shareData.url);
            return;
          }
        }
        window.prompt('Copy this URL:', shareData.url);
      };
      const downloadResumeHandler = () => window.print();
      const attachResumeActions = () => {
        if (!resumeContent) return;
        const shareBtn = resumeContent.querySelector('#shareBtn');
        const downloadBtn = resumeContent.querySelector('#downloadBtn');
        shareBtn?.addEventListener('click', shareResumeHandler);
        downloadBtn?.addEventListener('click', downloadResumeHandler);
      };
      const loadResumeContent = async () => {
        if (!resumeContent) return;
        try {
          const response = await fetch('./resume/index.html');
          if (!response.ok) throw new Error('Failed to fetch resume');
          const html = await response.text();
          const parser = new DOMParser();
          const doc = parser.parseFromString(html, 'text/html');
          const source = doc.querySelector('.content-wrapper') || doc.body;
          if (!source) {
            resumeContent.textContent = 'Resume content unavailable.';
            return;
          }
          source.querySelectorAll('script, style, link, meta, canvas').forEach((node) => node.remove());
          resumeContent.innerHTML = source.innerHTML;
          attachResumeActions();
        } catch (error) {
          resumeContent.textContent = 'Unable to load resume.';
        }
      };
      loadResumeContent();
      const showResumeLayer = () => {
        resumeLayer.scrollTop = 0;
        resumeLayer.classList.add('visible');
      };
      const hideResumeLayer = () => resumeLayer.classList.remove('visible');
      resumeLayer.addEventListener('click', (event) => {
        if (event.target === resumeLayer) hideResumeLayer();
      });
      window.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') hideResumeLayer();
      });
      window.addEventListener('wheel', (event) => {
        if (resumeLayer.classList.contains('visible')) return;
        if (event.deltaY > 5) showResumeLayer();
      }, { passive: true });
      resumeLayer.addEventListener('wheel', (event) => {
        if (!resumeLayer.classList.contains('visible')) return;
        if (resumeLayer.scrollTop <= 0 && event.deltaY < -5) {
          hideResumeLayer();
        }
      }, { passive: true });

      const raycaster = new THREEGL.Raycaster();
      const pointer = new THREEGL.Vector2(-10, -10);
      const clickables = [];
      let lastHover = null;
      const pointerWorld = new THREEGL.Vector2();
      let dragTarget = null;
      const dragOffset = new THREEGL.Vector2();
      let dragMoved = false;
      let didDrag = false;
      const draggableWords = [];
      let currentAspect = window.innerWidth / window.innerHeight;

      function clampToRange(value, limit) {
        if (limit <= 0) return 0;
        return Math.min(Math.max(value, -limit), limit);
      }

      const WHITE = new THREEGL.Color(0xffffff);
      const ACCENT = new THREEGL.Color(getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#00e5ff');
      let hasWebGPU = true;

      // ---------- INIT ----------
      (async () => {
        await initBackground();
        await initTextOverlay();
        onResize();
        animate();
      })();

      async function initBackground() {
        if (!WebGPU.isAvailable()) {
          const err = WebGPU.getErrorMessage();
          err.style.position = 'fixed';
          err.style.zIndex = 2;
          err.style.left = '50%';
          err.style.top = '35%';
          err.style.transform = 'translateX(-50%)';
          document.body.appendChild(err);
          bgCanvas.style.display = 'none';
          hasWebGPU = false;
          return;
        }

        const aspect = window.innerWidth / window.innerHeight;
        // Ortho in NDC-ish space (height ~2, width ~2*aspect)
        bgCamera = new THREEGPU.OrthographicCamera(-aspect, aspect, 1, -1, 0, 10);
        bgCamera.position.z = 1;
        uAspect.value = aspect;

        bgScene = new THREEGPU.Scene();

        // Make sure your imports include vec3 (and uniform if you use it):
// import { texture, textureStore, Fn, instanceIndex, float, uvec2, vec2, vec3, vec4, uniform } from 'three/tsl';

// Compute texture (animated, reactive)
const width = 768, height = 768; // adjust for perf/quality
const storageTexture = new THREEGPU.StorageTexture(width, height);

// Reactive plasma kernel with time/mouse/aspect + TECH PALETTE (Option 5)
const computeTexture = Fn(({ storageTexture, uTime, uMouse, uAspect }) => {
  const px  = instanceIndex.mod(width);
  const py  = instanceIndex.div(width);
  const uvx = float(px).div(float(width));
  const uvy = float(py).div(float(height));
  const indexUV = uvec2(px, py);

  // Centered coords with aspect correction
  const cx = uvx.mul(2.0).sub(1.0).mul(uAspect);
  const cy = uvy.mul(2.0).sub(1.0);

  // Mouse-centered ripple (mouse in [0..1], remap to [-1..1])
  const mx = uMouse.x.mul(2.0).sub(1.0).mul(uAspect);
  const my = uMouse.y.mul(2.0).sub(1.0);
  const dx = cx.sub(mx);
  const dy = cy.sub(my);
  const dist = dx.mul(dx).add(dy.mul(dy)).sqrt();

  // Time scroll
  const t = uTime.mul(0.18);
  const x = uvx.mul(6.0).add(t);
  const y = uvy.mul(6.0).sub(t.mul(0.6));

  // Plasma base
  const v1 = x.sin();
  const v2 = y.cos();
  const v3 = x.add(y).sin();
  const ripple = dist.mul(12.0).sub(t.mul(3.0)).sin().mul(0.7);
  const v = v1.mul(0.5).add(v2.mul(0.5)).add(v3.mul(0.5)).add(ripple);

  // base signal as 3 channels
  const base = vec3(
    v,
    v.add(1.57),
    v.add(3.14159)
  ).sin();

  // rotate in RGB space
  const ang = uTime.mul(0.6);
  const ca = ang.cos();
  const sa = ang.sin();

  // 3x3 rotation-ish (Y-then-Z)
  const m00 = ca;          const m01 = sa.mul(-1.0); const m02 = float(0.0);
  const m10 = sa;          const m11 = ca;           const m12 = float(0.0);
  const m20 = float(0.0);  const m21 = float(0.0);   const m22 = float(1.0);

  const rot = vec3(
    base.x.mul(m00).add(base.y.mul(m01)).add(base.z.mul(m02)),
    base.x.mul(m10).add(base.y.mul(m11)).add(base.z.mul(m12)),
    base.x.mul(m20).add(base.y.mul(m21)).add(base.z.mul(m22))
  );

  // slight contrast curve
  const col = rot.mul(0.5).add(0.5).pow(1.1);

  const r = col.x;
  const g = col.y;
  const b_ = col.z;

  textureStore(storageTexture, indexUV, vec4(r, g, b_, 1.0)).toWriteOnly();
});


        // Build compute node with uniforms
        computeNode = computeTexture({ storageTexture, uTime, uMouse, uAspect }).compute(width * height);

        const bgMat = new THREEGPU.MeshBasicNodeMaterial();
        bgMat.colorNode = texture(storageTexture);

        bgPlane = new THREEGPU.Mesh(new THREEGPU.PlaneGeometry(2 * aspect, 2), bgMat);
        bgPlane.position.z = -0.5;
        bgScene.add(bgPlane);

        gpuRenderer = new THREEGPU.WebGPURenderer({ antialias: true, canvas: bgCanvas, powerPreference: 'high-performance' });
        const dpr = Math.min(window.devicePixelRatio, 2);
        gpuRenderer.setPixelRatio(dpr);
        gpuRenderer.setSize(window.innerWidth, window.innerHeight);
        await gpuRenderer.init();

        // keep the background canvas sized correctly
        window.addEventListener('resize', onResize);
      }

      async function initTextOverlay() {
        // Ortho camera for text too → predictable layout
        const aspect = window.innerWidth / window.innerHeight;
        currentAspect = aspect;
        textCamera = new THREEGL.OrthographicCamera(-aspect, aspect, 1, -1, -10, 10);
        textCamera.position.z = 1;

        textScene = new THREEGL.Scene();
        textScene.background = null;

        glRenderer = new THREEGL.WebGLRenderer({ antialias: true, alpha: true, canvas: textCanvas });
        glRenderer.setPixelRatio(window.devicePixelRatio);
        glRenderer.setSize(window.innerWidth, window.innerHeight);
        glRenderer.setClearColor(0x000000, 0);

        // Materials: solid white, no depth test to avoid z-fighting
        const fillMat = new THREEGL.MeshBasicMaterial({ color: 0xffffff, side: THREEGL.DoubleSide, depthTest: false });
        const strokeMat = new THREEGL.MeshBasicMaterial({ color: 0xffffff, side: THREEGL.DoubleSide, depthTest: false });

        const font = await loadZippedTypeface(
          'fonts/MPLUSRounded1c/MPLUSRounded1c-Regular.typeface.json.zip',
          'MPLUSRounded1c-Regular.typeface.json'
        );

        // Font sizes: Pedro Pita = H1, Studio/Resume/Email = H2
        const responsiveScale = Math.min(1, Math.max(window.innerWidth / 900, 0.65));
        const H1 = 0.10 * responsiveScale;   // Pedro Pita
        const H2 = 0.04 * responsiveScale;   // Studio, Resume, Email

        const wordSpecs = [
          { text: 'Pedro', height: H1 },
          { text: 'Pita', height: H1 },
          { text: 'Studio', height: H2, url: 'https://ironsignalworks.com' },
          { text: 'Resume', height: H2, action: 'resume' },
          { text: 'hello@pedropita.dev', height: H2, url: 'mailto:hello@pedropita.dev' }
        ];
        const horizontalLimit = Math.max(aspect * 0.65 * responsiveScale, 0.35);
        const verticalLimit = Math.min(0.85, 0.65 + responsiveScale * 0.3);
        const placementPadding = 0.05 + (1 - responsiveScale) * 0.08;
        const placementAttempts = 120;

        function overlapsCandidate(x, y, width, height, existing) {
          const bounds = existing.userData.bounds;
          if (!bounds) return false;
          const halfWidth = (width + bounds.width) / 2 + placementPadding;
          const halfHeight = (height + bounds.height) / 2 + placementPadding;
          return Math.abs(x - existing.position.x) < halfWidth && Math.abs(y - existing.position.y) < halfHeight;
        }

        function findSpawnPosition(width, height) {
          const marginX = width / 2 + placementPadding;
          const marginY = height / 2 + placementPadding;
          const baseHorizontalSpan = Math.min(horizontalLimit, aspect);
          const randomLimitX = Math.max(baseHorizontalSpan - marginX, 0.1);
          const randomLimitY = Math.max(verticalLimit - marginY, 0.1);
          const viewLimitX = Math.max(aspect - marginX, marginX);
          const viewLimitY = Math.max(1 - marginY, marginY);

          for (let attempt = 0; attempt < placementAttempts; attempt++) {
            const xCandidate = (Math.random() * 2 - 1) * randomLimitX;
            const yCandidate = (Math.random() * 2 - 1) * randomLimitY;
            const x = clampToRange(xCandidate, viewLimitX);
            const y = clampToRange(yCandidate, viewLimitY);
            let blocked = false;
            for (const existing of draggableWords) {
              if (overlapsCandidate(x, y, width, height, existing)) {
                blocked = true;
                break;
              }
            }
            if (!blocked) return { x, y };
          }

          const fallbackScaleX = 0.5 + responsiveScale * 0.5;
          const fallbackScaleY = 0.4 + responsiveScale * 0.5;
          const fallbackOffsets = [
            { x: 0, y: 0 },
            { x: -0.5, y: 0.3 },
            { x: 0.5, y: 0.3 },
            { x: -0.5, y: -0.3 },
            { x: 0.5, y: -0.3 },
            { x: -0.7, y: 0 },
            { x: 0.7, y: 0 },
            { x: 0, y: -0.5 }
          ].map((entry) => ({
            x: entry.x * fallbackScaleX,
            y: entry.y * fallbackScaleY
          }));
          for (const offset of fallbackOffsets) {
            const x = clampToRange(offset.x * randomLimitX, viewLimitX);
            const y = clampToRange(offset.y * randomLimitY, viewLimitY);
            let blocked = false;
            for (const existing of draggableWords) {
              if (overlapsCandidate(x, y, width, height, existing)) {
                blocked = true;
                break;
              }
            }
            if (!blocked) return { x, y };
          }

          const fallbackX = clampToRange(((draggableWords.length % 3) - 1) * 0.3, viewLimitX);
          const fallbackY = clampToRange(-0.4 + Math.floor(draggableWords.length / 3) * 0.2, viewLimitY);
          return { x: fallbackX, y: fallbackY };
        }

        for (const spec of wordSpecs) {
        const hitPadding = spec.url || spec.action ? 0.25 : 0.015;
        const wordGroup = makeStrokeText(font, spec.text, spec.height, fillMat.clone(), strokeMat.clone(), hitPadding);
          wordGroup.userData.isDraggableWord = true;

          // If it has a URL or action, it's also a clickable link
          if (spec.url || spec.action) {
            if (spec.url) wordGroup.userData.url = spec.url;
            if (spec.action) wordGroup.userData.action = spec.action;
            wordGroup.userData.isLink = true;
            wordGroup.userData.setHover = (hover) => {
              for (const child of wordGroup.children) {
                if (child.material && child.material.color) {
                  child.material.color.copy(hover ? ACCENT : WHITE);
                  child.material.needsUpdate = true;
                }
              }
            };
            clickables.push(wordGroup);
          }

          const bounds = wordGroup.userData.bounds ?? { width: Math.max(spec.text.length * 0.09, 0.2), height: spec.height };
          const { x, y } = findSpawnPosition(bounds.width, bounds.height);
          wordGroup.position.set(x, y, 0);
          draggableWords.push(wordGroup);
          textScene.add(wordGroup);
        }

        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('pointerup', onPointerUp);
        window.addEventListener('pointercancel', onPointerUp);
        window.addEventListener('click', onClick);
        window.addEventListener('resize', onResize);
      }

      // ---------- Text helpers ----------
      async function loadZippedTypeface(zipPath, jsonName) {
        const buf = await new THREEGL.FileLoader().setResponseType('arraybuffer').loadAsync(zipPath);
        const zip = unzipSync(new Uint8Array(buf));
        const json = strFromU8(new Uint8Array(zip[jsonName].buffer));
        return new Font(JSON.parse(json));
      }

      function makeStrokeText(font, text, targetHeight, fillMat, strokeMat, hitboxPadding = 0.015) {
        // Build at a big base size for precision
        const baseSize = 100;
        const shapes = font.generateShapes(text, baseSize, 'ltr');

        // --- Fill geometry ---
        const geom = new THREEGL.ShapeGeometry(shapes);
        geom.computeBoundingBox();
        const bb = geom.boundingBox;

        // center the text around (0,0)
        const xMid = -0.5 * (bb.max.x - bb.min.x);
        const yMid = -0.5 * (bb.max.y - bb.min.y);
        geom.translate(xMid, yMid, 0);

        const group = new THREEGL.Group();

        // Solid fill (white), no depth fighting
        const fill = new THREEGL.Mesh(geom, fillMat);
        fill.material.depthTest = false;
        fill.material.depthWrite = false;
        fill.renderOrder = 1;
        group.add(fill);

        // --- Stroke geometry (outlines) ---
        const holeShapes = [];
        for (let i = 0; i < shapes.length; i++) {
          const s = shapes[i];
          if (s.holes && s.holes.length) holeShapes.push(...s.holes);
        }
        shapes.push(...holeShapes);

        const strokeWidth = 5; // tweak (2–8)
        const style = SVGLoader.getStrokeStyle(strokeWidth, '#ffffff');

        for (let i = 0; i < shapes.length; i++) {
          const pts = shapes[i].getPoints();
          const g = SVGLoader.pointsToStroke(pts, style);
          g.translate(xMid, yMid, 0);
          const strokeMesh = new THREEGL.Mesh(g, strokeMat);
          strokeMesh.material.depthTest = false;
          strokeMesh.material.depthWrite = false;
          strokeMesh.renderOrder = 2;
          group.add(strokeMesh);
        }

        // --- Correct scaling ---
        const ascender = bb.max.y;
        const baseline = Math.max(bb.min.y, 0);
        const capHeight = Math.max(ascender - baseline, 0.001);
        const scale = targetHeight / capHeight;
        group.scale.set(scale, scale, 1);

        const widthWorld = (bb.max.x - bb.min.x) * scale;
        const worldHeight = (bb.max.y - bb.min.y) * scale;

        // Add invisible bounding box plane for easier touch/click detection
        // hitboxPadding provided per word; clickable terms get larger targets
        const hitboxGeom = new THREEGL.PlaneGeometry(
          widthWorld + hitboxPadding * 2,
          worldHeight + hitboxPadding * 2
        );
        const hitboxMat = new THREEGL.MeshBasicMaterial({
          transparent: true,
          opacity: 0,
          depthTest: false,
          depthWrite: false
        });
        const hitbox = new THREEGL.Mesh(hitboxGeom, hitboxMat);
        hitbox.renderOrder = 0;
        hitbox.userData.isHitbox = true;
        group.add(hitbox);

        group.userData.bounds = { width: widthWorld, height: worldHeight };
        group.userData.getMeshes = () => group.children;
        return group;
      }

      function place(group, x, y) {
        group.position.set(x, y, 0);
      }

      // ---------- Interaction ----------
      function syncPointerFromEvent(e) {
        const rect = textCanvas.getBoundingClientRect();
        pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        pointerWorld.set(pointer.x * currentAspect, pointer.y);
      }

      function onPointerMove(e) {
        // existing text interactions
        syncPointerFromEvent(e);

        if (dragTarget) {
          dragMoved = true;
          const newX = pointerWorld.x - dragOffset.x;
          const newY = pointerWorld.y - dragOffset.y;
          const bounds = dragTarget.userData.bounds || { width: 0, height: 0 };
          const padding = 0.05;
          const limitX = Math.max(currentAspect - bounds.width / 2 - padding, 0);
          const limitY = Math.max(1 - bounds.height / 2 - padding, 0);
          const clampedX = clampToRange(newX, limitX);
          const clampedY = clampToRange(newY, limitY);
          dragTarget.position.set(clampedX, clampedY, 0);
          return;
        }

        raycaster.setFromCamera(pointer, textCamera);

        const meshes = [];
        for (const obj of clickables) meshes.push(...obj.userData.getMeshes());

        const hits = raycaster.intersectObjects(meshes, false);
        let hoverGroup = null;

        if (hits.length) {
          let node = hits[0].object;
          while (node && node.parent) {
            if (node.userData?.isLink) { hoverGroup = node; break; }
            if (node.parent.userData?.isLink) { hoverGroup = node.parent; break; }
            node = node.parent;
          }
        }

        if (hoverGroup !== lastHover) {
          if (lastHover) lastHover.userData.setHover(false);
          if (hoverGroup) hoverGroup.userData.setHover(true);
          lastHover = hoverGroup || null;
          document.body.classList.toggle('hover-link', !!lastHover);
        }
      }

      function findDraggableGroup(node) {
        while (node) {
          if (node.userData?.isDraggableWord) return node;
          node = node.parent;
        }
        return null;
      }

      function onPointerDown(e) {
        didDrag = false;
        syncPointerFromEvent(e);

        const meshes = [];
        for (const word of draggableWords) meshes.push(...word.userData.getMeshes());
        if (!meshes.length) return;

        raycaster.setFromCamera(pointer, textCamera);
        const hits = raycaster.intersectObjects(meshes, false);
        if (!hits.length) return;

        const target = findDraggableGroup(hits[0].object);
        if (!target) return;

        dragTarget = target;
        dragOffset.set(pointerWorld.x - target.position.x, pointerWorld.y - target.position.y);
        dragMoved = false;
      }

      function onPointerUp() {
        didDrag = dragMoved;
        dragTarget = null;
        dragMoved = false;
      }

      function onClick() {
        if (didDrag) {
          didDrag = false;
          return;
        }
        if (!lastHover) return;
        const { url, action } = lastHover.userData;
        if (action === 'resume') {
          showResumeLayer();
          return;
        }
        if (url) window.open(url, '_blank', 'noopener');
      }

      // ---------- Resize / Render loop ----------
      function onResize() {
        const w = window.innerWidth, h = window.innerHeight;
        const aspect = w / h;
        currentAspect = aspect;

        // BG
        if (hasWebGPU && gpuRenderer && bgCamera && bgPlane) {
          gpuRenderer.setSize(w, h);
          bgCamera.left = -aspect;
          bgCamera.right = aspect;
          bgCamera.updateProjectionMatrix();
          bgPlane.scale.set(aspect, 1, 1);
          uAspect.value = aspect; // keep plasma round-ish across aspect ratios
        }

        // Text
        if (glRenderer && textCamera) {
          glRenderer.setSize(w, h);
          textCamera.left = -aspect;
          textCamera.right = aspect;
          textCamera.updateProjectionMatrix();
        }

        if (draggableWords.length) {
          const padding = 0.05;
          for (const word of draggableWords) {
            const bounds = word.userData.bounds || { width: 0, height: 0 };
            const limitX = Math.max(currentAspect - bounds.width / 2 - padding, 0);
            const limitY = Math.max(1 - bounds.height / 2 - padding, 0);
            word.position.x = clampToRange(word.position.x, limitX);
            word.position.y = clampToRange(word.position.y, limitY);
          }
        }
      }

      function animate(t = 0) {
        // uniforms update
        uTime.value = t * 0.001;

        // smooth mouse (lerp)
        const lerp = (a, b, s) => a + (b - a) * s;
        uMouse.value.x = lerp(uMouse.value.x, targetMouse.x, 0.15);
        uMouse.value.y = lerp(uMouse.value.y, targetMouse.y, 0.15);

        // compute every frame, then render both layers
        if (hasWebGPU && gpuRenderer && computeNode) gpuRenderer.compute(computeNode);
        if (hasWebGPU && gpuRenderer && bgScene && bgCamera) gpuRenderer.render(bgScene, bgCamera);
        if (glRenderer && textScene && textCamera) glRenderer.render(textScene, textCamera);

        requestAnimationFrame(animate);
      }
    </script>
  </body>
</html>