<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Pedro Pita â€” creative web engineering</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ccircle cx='32' cy='32' r='30' fill='%2300e5ff'/%3E%3Ctext x='32' y='39' text-anchor='middle' font-size='28' fill='%23000' font-family='Arial,Helvetica,sans-serif'%3EP%3C/text%3E%3C/svg%3E">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
      :root { --accent:#00e5ff; }
      *, *::before, *::after { font-family: 'Roboto', 'Helvetica Neue', 'Arial', sans-serif !important; }
      html, body { height: 100%; font-family: 'Roboto', 'Helvetica Neue', 'Arial', sans-serif; }
      body {
        margin: 0;
        background: #000;
        overflow: hidden;
        font-family: 'Roboto', 'Helvetica Neue', 'Arial', sans-serif;
      }
      #bgCanvas, #textCanvas { position: fixed; inset: 0; width: 100%; height: 100%; }
      #bgCanvas { z-index: 0; pointer-events: none; }
      #textCanvas { z-index: 1; }
      body.hover-link { cursor: pointer; }
      #resumeLayer {
        position: fixed;
        inset: 0;
        background: #000;
        transform: translateY(110%);
        transition: transform 0.9s cubic-bezier(0.22, 1, 0.36, 1);
        z-index: 3;
        pointer-events: none;
        overflow-y: auto;
        padding: 2rem;
        scrollbar-width: thin;
        scrollbar-color: #1a1a1a #000;
      }
      #resumeLayer.visible {
        transform: translateY(0);
        pointer-events: auto;
      }
      #resumeLayer .resume-content {
        max-width: 960px;
        margin: 0 auto;
        color: rgba(255, 255, 255, 0.9);
        font-family: 'Roboto', 'Helvetica Neue', 'Arial', sans-serif !important;
        line-height: 1.6;
      }
      #resumeLayer .resume-content,
      #resumeLayer .resume-content *::before,
      #resumeLayer .resume-content *::after {
        font-family: 'Roboto', 'Helvetica Neue', 'Arial', sans-serif !important;
      }
      #resumeLayer .resume-content * {
        font-family: 'Roboto', 'Helvetica Neue', 'Arial', sans-serif !important;
      }
      #resumeLayer .resume-content .actions {
        display: flex;
        justify-content: flex-start;
        align-items: center;
        margin-bottom: 1rem;
        gap: 0.5rem;
      }
      #resumeLayer .resume-content .btn {
        appearance: none;
        border: 1px solid rgba(255, 255, 255, 0.35);
        background: #000;
        color: #fff;
        font-family: 'Roboto', 'Helvetica Neue', 'Arial', sans-serif;
        font-size: 0.95rem;
        padding: 0.4rem 0.85rem;
        border-radius: 0;
        cursor: pointer;
        transition: border-color 0.2s, transform 0.08s;
      }
      #resumeLayer .resume-content .btn:hover { border-color: rgba(255, 255, 255, 0.65); }
      #resumeLayer .resume-content .btn:active { transform: translateY(1px); }
      @media (max-width: 720px) {
        #resumeLayer {
          padding: 1.25rem;
        }
      }
      #resumeLayer .resume-content h1,
      #resumeLayer .resume-content h2,
      #resumeLayer .resume-content h3,
      #resumeLayer .resume-content h4,
      #resumeLayer .resume-content h5,
      #resumeLayer .resume-content h6 {
        font-family: 'Roboto', 'Helvetica Neue', 'Arial', sans-serif !important;
        margin-top: 1.25rem;
        margin-bottom: 0.35rem;
        color: #00e5ff;
        font-weight: 700;
      }
      #resumeLayer .resume-content p,
      #resumeLayer .resume-content ul,
      #resumeLayer .resume-content li,
      #resumeLayer .resume-content span,
      #resumeLayer .resume-content div {
        font-family: 'Roboto', 'Helvetica Neue', 'Arial', sans-serif !important;
      }
      #resumeLayer .resume-content p,
      #resumeLayer .resume-content ul {
        margin-bottom: 1rem;
      }
      #resumeLayer .resume-content a {
        color: #00e5ff;
        font-family: 'Roboto', 'Helvetica Neue', 'Arial', sans-serif !important;
      }
      #resumeLayer::-webkit-scrollbar {
        width: 10px;
      }
      #resumeLayer::-webkit-scrollbar-track {
        background: #000;
      }
      #resumeLayer::-webkit-scrollbar-thumb {
        background: #1a1a1a;
      }
      @media print {
        @page { margin: 8mm; size: A4 portrait; }
        html, body {
          margin: 0;
          height: auto;
          overflow: visible;
          font-size: calc(0.78rem + 2px);
        }
        #bgCanvas, #textCanvas {
          display: none;
        }
        #resumeLayer {
          position: static;
          inset: auto;
          height: auto;
          overflow: visible;
          transform: translateY(0) !important;
          pointer-events: none;
          background: #000;
          padding: 0;
          scrollbar-width: none;
          box-shadow: none;
          max-width: 100%;
          width: 100%;
          page-break-after: avoid;
          page-break-inside: avoid;
        }
        #resumeLayer .resume-content {
          max-width: 100%;
          padding: 0;
          font-size: calc(0.85rem + 2px);
          line-height: 1.4;
          page-break-inside: avoid;
        }
        #resumeLayer .resume-content p,
        #resumeLayer .resume-content .meta {
          margin-bottom: 0.65rem;
        }
        #resumeLayer .resume-content p:last-child {
          margin-bottom: 0;
        }
        #resumeLayer .resume-content .actions {
          display: none !important;
        }
        #resumeLayer .resume-content h1,
        #resumeLayer .resume-content h2,
        #resumeLayer .resume-content h3,
        #resumeLayer .resume-content h4,
        #resumeLayer .resume-content h5,
        #resumeLayer .resume-content h6 {
          color: #f5f5f5;
        }
      }
      #error {
        position: fixed;
        top: 20px;
        left: 20px;
        color: #f00;
        background: rgba(0,0,0,0.9);
        padding: 10px;
        font-family: monospace;
        z-index: 1000;
        display: none;
      }
    </style>
  </head>
  <body>
  
    <div id="error"></div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      const errorDiv = document.getElementById('error');
      
      window.addEventListener('error', (e) => {
        errorDiv.style.display = 'block';
        errorDiv.textContent = 'Error: ' + e.message;
        console.error('Error:', e);
      });

      try {
        const THREE = await import('three');
        const { SVGLoader } = await import('three/addons/loaders/SVGLoader.js');
        const { Font } = await import('three/addons/loaders/FontLoader.js');

        console.log('Three.js loaded successfully');

        // Random seed for background variation
        const randomSeed = Math.random() * 1000;

        // ---------- BACKGROUND (WebGL) ----------
        const bgCanvas = document.createElement('canvas');
        bgCanvas.id = 'bgCanvas';
        document.body.appendChild(bgCanvas);

        const aspect = window.innerWidth / window.innerHeight;
        const bgCamera = new THREE.OrthographicCamera(-aspect, aspect, 1, -1, 0, 10);
        bgCamera.position.z = 1;

        const bgScene = new THREE.Scene();

        // Static mouse position (randomized once, doesn't follow pointer)
        const staticMouse = new THREE.Vector2(Math.random(), Math.random());

        const shaderMaterial = new THREE.ShaderMaterial({
          uniforms: {
            uTime: { value: 0 },
            uMouse: { value: staticMouse },
            uAspect: { value: aspect },
            uSeed: { value: randomSeed }
          },
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vUv = uv;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            uniform float uTime;
            uniform vec2 uMouse;
            uniform float uAspect;
            uniform float uSeed;
            varying vec2 vUv;

            void main() {
              vec2 uv = vUv;
              vec2 centered = (uv * 2.0 - 1.0) * vec2(uAspect, 1.0);
              vec2 mouse = (uMouse * 2.0 - 1.0) * vec2(uAspect, 1.0);
              float dist = length(centered - mouse);

              float t = uTime * 0.18 + uSeed;
              float x = uv.x * 6.0 + t;
              float y = uv.y * 6.0 - t * 0.6 + uSeed * 0.5;

              float v1 = sin(x + uSeed);
              float v2 = cos(y);
              float v3 = sin(x + y + uSeed * 0.3);
              float ripple = sin(dist * 12.0 - t * 3.0 + uSeed) * 0.7;
              float v = v1 * 0.5 + v2 * 0.5 + v3 * 0.5 + ripple;

              vec3 base = sin(vec3(v, v + 1.57, v + 3.14159));

              float ang = uTime * 0.6 + uSeed * 0.2;
              float ca = cos(ang);
              float sa = sin(ang);

              mat3 rot = mat3(
                ca, -sa, 0.0,
                sa,  ca, 0.0,
                0.0, 0.0, 1.0
              );

              vec3 col = rot * base;
              col = pow(col * 0.5 + 0.5, vec3(1.1));

              gl_FragColor = vec4(col, 1.0);
            }
          `
        });

        const bgPlane = new THREE.Mesh(
          new THREE.PlaneGeometry(2 * aspect, 2),
          shaderMaterial
        );
        bgPlane.position.z = -0.5;
        bgScene.add(bgPlane);

        const bgRenderer = new THREE.WebGLRenderer({ antialias: true, canvas: bgCanvas });
        bgRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        bgRenderer.setSize(window.innerWidth, window.innerHeight);

        console.log('Background renderer created');

        // ---------- TEXT OVERLAY (WebGL) ----------
        const textCanvas = document.createElement('canvas');
        textCanvas.id = 'textCanvas';
        document.body.appendChild(textCanvas);

        const textCamera = new THREE.OrthographicCamera(-aspect, aspect, 1, -1, -10, 10);
        textCamera.position.z = 1;

        const textScene = new THREE.Scene();

        const textRenderer = new THREE.WebGLRenderer({ 
          antialias: true, 
          alpha: true, 
          canvas: textCanvas 
        });
        textRenderer.setPixelRatio(window.devicePixelRatio);
        textRenderer.setSize(window.innerWidth, window.innerHeight);
        textRenderer.setClearColor(0x000000, 0);

        console.log('Text renderer created');

        // Resume layer
        const resumeLayer = document.createElement('div');
        resumeLayer.id = 'resumeLayer';
        resumeLayer.innerHTML = `<div class="resume-content"></div>`;
        document.body.appendChild(resumeLayer);
        const resumeContent = resumeLayer.querySelector('.resume-content');
        
        const showResumeLayer = () => {
          resumeLayer.scrollTop = 0;
          resumeLayer.classList.add('visible');
        };
        
        const hideResumeLayer = () => resumeLayer.classList.remove('visible');
        
        resumeLayer.addEventListener('click', (event) => {
          if (event.target === resumeLayer) hideResumeLayer();
        });
        
        window.addEventListener('keydown', (event) => {
          if (event.key === 'Escape') hideResumeLayer();
        });

        // Scroll tracking for resume
        let scrollAccumulator = 0;
        const scrollThreshold = 100;

        window.addEventListener('wheel', (event) => {
          if (resumeLayer.classList.contains('visible')) {
            // If resume is visible, only hide on scroll up at top
            if (resumeLayer.scrollTop <= 0 && event.deltaY < 0) {
              event.preventDefault();
              hideResumeLayer();
              scrollAccumulator = 0;
            }
          } else {
            // If resume is hidden, show on scroll down
            scrollAccumulator += event.deltaY;
            
            if (scrollAccumulator > scrollThreshold) {
              showResumeLayer();
              scrollAccumulator = 0;
            } else if (scrollAccumulator < -scrollThreshold) {
              scrollAccumulator = 0;
            }
          }
        }, { passive: false });

        // Load resume content
        const loadResumeContent = async () => {
          if (!resumeContent) return;
          try {
            const response = await fetch('./resume/index.html');
            if (!response.ok) throw new Error('Failed to fetch resume');
            const html = await response.text();
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const source = doc.querySelector('.content-wrapper') || doc.body;
            if (!source) {
              resumeContent.textContent = 'Resume content unavailable.';
              return;
            }
            source.querySelectorAll('script, style, link, meta, canvas').forEach((node) => node.remove());
            
            // Remove all inline styles that might override fonts
            source.querySelectorAll('[style]').forEach((node) => {
              const style = node.getAttribute('style');
              if (style && (style.includes('font-family') || style.includes('font'))) {
                // Remove font-related inline styles
                const newStyle = style.split(';')
                  .filter(rule => !rule.trim().toLowerCase().includes('font'))
                  .join(';');
                if (newStyle.trim()) {
                  node.setAttribute('style', newStyle);
                } else {
                  node.removeAttribute('style');
                }
              }
            });
            
            // Set resume content
            resumeContent.innerHTML = source.innerHTML;
            
            // Apply Roboto to all elements after loading
            resumeContent.querySelectorAll('*').forEach((el) => {
              el.style.fontFamily = "'Roboto', 'Helvetica Neue', 'Arial', sans-serif";
            });
            
            // Check if buttons already exist, if not create them
            let shareBtn = resumeContent.querySelector('#shareBtn');
            let downloadBtn = resumeContent.querySelector('#downloadBtn');
            
            if (!shareBtn || !downloadBtn) {
              // Remove any existing .actions div first
              const existingActions = resumeContent.querySelector('.actions');
              if (existingActions) existingActions.remove();
              
              // Create new action buttons
              const actionsDiv = document.createElement('div');
              actionsDiv.className = 'actions';
              actionsDiv.innerHTML = `
                <button class="btn" id="shareBtn">Share</button>
                <button class="btn" id="downloadBtn">Download PDF</button>
              `;
              
              // Insert buttons at the top
              resumeContent.insertBefore(actionsDiv, resumeContent.firstChild);
              
              // Get the newly created buttons
              shareBtn = resumeContent.querySelector('#shareBtn');
              downloadBtn = resumeContent.querySelector('#downloadBtn');
            }
            
            // Attach button handlers
            if (shareBtn) {
              shareBtn.addEventListener('click', async (event) => {
                const url = new URL(window.location.href);
                url.searchParams.set('clean', '1');
                const shareData = {
                  title: 'Pedro Pita - Resume',
                  text: 'Resume - Creative Technologist & Web Developer',
                  url: url.toString()
                };
                
                if (navigator.share) {
                  try {
                    await navigator.share(shareData);
                  } catch {
                    // user canceled
                  }
                  return;
                }
                
                if (navigator.clipboard && window.isSecureContext) {
                  try {
                    await navigator.clipboard.writeText(shareData.url);
                    const previous = shareBtn.textContent;
                    shareBtn.textContent = 'Link copied!';
                    setTimeout(() => {
                      shareBtn.textContent = previous;
                    }, 1400);
                    return;
                  } catch {
                    window.prompt('Copy this URL:', shareData.url);
                  }
                } else {
                  window.prompt('Copy this URL:', shareData.url);
                }
              });
            }
            
            if (downloadBtn) {
              downloadBtn.addEventListener('click', () => {
                window.print();
              });
            }
          } catch (error) {
            resumeContent.textContent = 'Unable to load resume.';
          }
        };
        loadResumeContent();

        // Load font and create text
        console.log('Loading font...');
        const response = await fetch('https://cdn.jsdelivr.net/npm/three@0.170.0/examples/fonts/helvetiker_regular.typeface.json');
        const fontData = await response.json();
        const font = new Font(fontData);
        console.log('Font loaded');

        const fillMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, depthTest: false });
        const strokeMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, depthTest: false });

        const responsiveScale = Math.min(1, Math.max(window.innerWidth / 900, 0.65));
        const H1 = 0.10 * responsiveScale;
        const H2 = 0.04 * responsiveScale;

        const wordSpecs = [
          { text: 'Pedro', height: H1 },
          { text: 'Pita', height: H1 },
          { text: 'Studio', height: H2, url: 'https://ironsignalworks.com' },
          { text: 'Resume', height: H2, action: 'resume' },
          { text: 'hello@pedropita.dev', height: H2, url: 'mailto:hello@pedropita.dev' }
        ];

        const WHITE = new THREE.Color(0xffffff);
        const ACCENT = new THREE.Color(0x00e5ff);
        const clickables = [];
        const draggableWords = [];
        let lastHover = null;

        function makeStrokeText(font, text, targetHeight, fillMat, strokeMat) {
          const baseSize = 100;
          const shapes = font.generateShapes(text, baseSize);

          const geom = new THREE.ShapeGeometry(shapes);
          geom.computeBoundingBox();
          const bb = geom.boundingBox;

          const xMid = -0.5 * (bb.max.x - bb.min.x);
          const yMid = -0.5 * (bb.max.y - bb.min.y);
          geom.translate(xMid, yMid, 0);

          const group = new THREE.Group();

          const fill = new THREE.Mesh(geom, fillMat);
          fill.material.depthTest = false;
          fill.material.depthWrite = false;
          fill.renderOrder = 1;
          group.add(fill);

          const holeShapes = [];
          for (let i = 0; i < shapes.length; i++) {
            const s = shapes[i];
            if (s.holes && s.holes.length) holeShapes.push(...s.holes);
          }
          shapes.push(...holeShapes);

          const strokeWidth = 5;
          const style = SVGLoader.getStrokeStyle(strokeWidth, '#ffffff');

          for (let i = 0; i < shapes.length; i++) {
            const pts = shapes[i].getPoints();
            const g = SVGLoader.pointsToStroke(pts, style);
            g.translate(xMid, yMid, 0);
            const strokeMesh = new THREE.Mesh(g, strokeMat);
            strokeMesh.material.depthTest = false;
            strokeMesh.material.depthWrite = false;
            strokeMesh.renderOrder = 2;
            group.add(strokeMesh);
          }

          const ascender = bb.max.y;
          const baseline = Math.max(bb.min.y, 0);
          const capHeight = Math.max(ascender - baseline, 0.001);
          const scale = targetHeight / capHeight;
          group.scale.set(scale, scale, 1);

          const widthWorld = (bb.max.x - bb.min.x) * scale;
          const worldHeight = (bb.max.y - bb.min.y) * scale;

          const hitboxGeom = new THREE.PlaneGeometry(widthWorld + 0.1, worldHeight + 0.1);
          const hitboxMat = new THREE.MeshBasicMaterial({
            transparent: true,
            opacity: 0,
            depthTest: false
          });
          const hitbox = new THREE.Mesh(hitboxGeom, hitboxMat);
          hitbox.renderOrder = 0;
          group.add(hitbox);

          group.userData.bounds = { width: widthWorld, height: worldHeight };
          group.userData.getMeshes = () => group.children;
          return group;
        }

        // Random word placement with no overlaps
        let currentAspect = aspect;
        const padding = 0.1;
        const maxAttempts = 100;

        function isOverlapping(x, y, width, height, existingWords) {
          for (const word of existingWords) {
            const bounds = word.userData.bounds;
            const dx = Math.abs(x - word.position.x);
            const dy = Math.abs(y - word.position.y);
            const minDistX = (width + bounds.width) / 2 + padding;
            const minDistY = (height + bounds.height) / 2 + padding;
            
            if (dx < minDistX && dy < minDistY) {
              return true;
            }
          }
          return false;
        }

        function findRandomPosition(width, height, existingWords) {
          const marginX = width / 2 + padding;
          const marginY = height / 2 + padding;
          const maxX = currentAspect - marginX;
          const maxY = 1 - marginY;
          
          for (let attempt = 0; attempt < maxAttempts; attempt++) {
            const x = (Math.random() * 2 - 1) * maxX;
            const y = (Math.random() * 2 - 1) * maxY;
            
            if (!isOverlapping(x, y, width, height, existingWords)) {
              return { x, y };
            }
          }
          
          // Fallback: place in grid
          const col = existingWords.length % 3;
          const row = Math.floor(existingWords.length / 3);
          return {
            x: (col - 1) * 0.5,
            y: 0.3 - row * 0.3
          };
        }

        for (const spec of wordSpecs) {
          const wordGroup = makeStrokeText(font, spec.text, spec.height, fillMat.clone(), strokeMat.clone());
          
          const bounds = wordGroup.userData.bounds;
          const { x, y } = findRandomPosition(bounds.width, bounds.height, draggableWords);
          
          wordGroup.position.set(x, y, 0);
          wordGroup.userData.isDraggableWord = true;

          if (spec.url || spec.action) {
            if (spec.url) wordGroup.userData.url = spec.url;
            if (spec.action) wordGroup.userData.action = spec.action;
            wordGroup.userData.isLink = true;
            wordGroup.userData.setHover = (hover) => {
              for (const child of wordGroup.children) {
                if (child.material && child.material.color) {
                  child.material.color.copy(hover ? ACCENT : WHITE);
                  child.material.needsUpdate = true;
                }
              }
            };
            clickables.push(wordGroup);
          }

          draggableWords.push(wordGroup);
          textScene.add(wordGroup);
        }

        console.log('Text created, words:', draggableWords.length);

        // Interaction
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2(-10, -10);
        let dragTarget = null;
        let dragOffset = new THREE.Vector2();
        let dragMoved = false;
        let didDrag = false;

        function syncPointer(e) {
          const rect = textCanvas.getBoundingClientRect();
          pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
          pointer.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        }

        function clampPosition(word) {
          const bounds = word.userData.bounds;
          const maxX = currentAspect - bounds.width / 2 - padding;
          const maxY = 1 - bounds.height / 2 - padding;
          word.position.x = Math.max(-maxX, Math.min(maxX, word.position.x));
          word.position.y = Math.max(-maxY, Math.min(maxY, word.position.y));
        }

        window.addEventListener('pointermove', (e) => {
          syncPointer(e);

          if (dragTarget) {
            dragMoved = true;
            const worldX = pointer.x * currentAspect;
            const worldY = pointer.y;
            dragTarget.position.x = worldX - dragOffset.x;
            dragTarget.position.y = worldY - dragOffset.y;
            clampPosition(dragTarget);
            return;
          }

          raycaster.setFromCamera(pointer, textCamera);
          const meshes = [];
          for (const obj of clickables) meshes.push(...obj.userData.getMeshes());
          const hits = raycaster.intersectObjects(meshes, false);

          let hoverGroup = null;
          if (hits.length) {
            let node = hits[0].object;
            while (node && node.parent) {
              if (node.userData?.isLink) { hoverGroup = node; break; }
              if (node.parent.userData?.isLink) { hoverGroup = node.parent; break; }
              node = node.parent;
            }
          }

          if (hoverGroup !== lastHover) {
            if (lastHover) lastHover.userData.setHover(false);
            if (hoverGroup) hoverGroup.userData.setHover(true);
            lastHover = hoverGroup || null;
            document.body.classList.toggle('hover-link', !!lastHover);
          }
        });

        window.addEventListener('pointerdown', (e) => {
          syncPointer(e);
          didDrag = false;
          
          raycaster.setFromCamera(pointer, textCamera);
          const meshes = [];
          for (const word of draggableWords) meshes.push(...word.userData.getMeshes());
          const hits = raycaster.intersectObjects(meshes, false);
          
          if (hits.length) {
            let node = hits[0].object;
            while (node && node.parent) {
              if (node.userData?.isDraggableWord) { 
                dragTarget = node;
                const worldX = pointer.x * currentAspect;
                const worldY = pointer.y;
                dragOffset.set(worldX - dragTarget.position.x, worldY - dragTarget.position.y);
                dragMoved = false;
                break;
              }
              node = node.parent;
            }
          }
        });

        window.addEventListener('pointerup', () => {
          didDrag = dragMoved;
          dragTarget = null;
          dragMoved = false;
        });

        window.addEventListener('click', () => {
          if (didDrag) {
            didDrag = false;
            return;
          }
          if (!lastHover) return;
          const { url, action } = lastHover.userData;
          if (action === 'resume') {
            showResumeLayer();
          } else if (url) {
            window.open(url, '_blank', 'noopener');
          }
        });

        // Resize
        window.addEventListener('resize', () => {
          const w = window.innerWidth;
          const h = window.innerHeight;
          const newAspect = w / h;
          currentAspect = newAspect;

          bgRenderer.setSize(w, h);
          bgCamera.left = -newAspect;
          bgCamera.right = newAspect;
          bgCamera.updateProjectionMatrix();
          bgPlane.scale.set(newAspect, 1, 1);
          shaderMaterial.uniforms.uAspect.value = newAspect;

          textRenderer.setSize(w, h);
          textCamera.left = -newAspect;
          textCamera.right = newAspect;
          textCamera.updateProjectionMatrix();

          // Re-clamp all words to new bounds
          for (const word of draggableWords) {
            clampPosition(word);
          }
        });

        // Animation loop
        console.log('Starting animation loop');
        function animate(t = 0) {
          shaderMaterial.uniforms.uTime.value = t * 0.001;
          
          bgRenderer.render(bgScene, bgCamera);
          textRenderer.render(textScene, textCamera);
          
          requestAnimationFrame(animate);
        }
        
        animate();
        console.log('Animation started successfully');

      } catch (error) {
        errorDiv.style.display = 'block';
        errorDiv.textContent = 'Critical Error: ' + error.message;
        console.error('Critical error:', error);
      }
    </script>
  </body>
</html>
